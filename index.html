<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Pro Analyzer (Turbo Mode)</title>
    <style>
        :root {
            --bg: #101216;
            --surface: #1b2838;
            --border: #2a475e;
            --accent: #66c0f4;
            --text: #c7d5e0;
            --success: #a1cd44; 
            --xbox: #107C10;
            --ps: #00439C;
            --switch: #e60012;
            --db-color: #e51376;
        }

        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        /* Header & Controls */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        h1 { margin: 0; font-size: 20px; color: #fff; text-transform: uppercase; letter-spacing: 1px; }
        .storage-status { font-size: 12px; color: #888; font-style: italic; }

        .controls {
            display: grid;
            grid-template-columns: 1fr 220px;
            gap: 15px;
            margin-bottom: 20px;
            background: var(--surface);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        textarea {
            width: 100%;
            height: 80px;
            background: #0d1015;
            border: 1px solid var(--border);
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            resize: none;
            font-family: monospace;
            box-sizing: border-box;
        }

        .actions { display: flex; flex-direction: column; gap: 8px; }

        button {
            flex: 1;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            color: #fff;
            font-size: 12px;
            padding: 8px;
        }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        #btnProcess { background: linear-gradient(90deg, #06BFFF, #2D73FF); font-size: 14px; }
        #btnExport { background: #4c6b22; }
        #btnClear { background: #3a3a3a; }
        #btnResetStorage { background: #cd5444; }

        /* Filter Bar */
        .filter-container { margin-bottom: 10px; }
        .filter-input {
            width: 100%;
            padding: 10px;
            background: #171a21;
            border: 1px solid var(--border);
            color: #fff;
            border-radius: 4px;
            box-sizing: border-box;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 4px;
            background: #000;
            margin-bottom: 15px;
            display: none;
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.3s;
        }

        /* Table */
        .table-container {
            flex: 1;
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: #171a21;
        }

        table { width: 100%; border-collapse: collapse; font-size: 13px; white-space: nowrap; }
        
        th {
            background: #20242b;
            position: sticky;
            top: 0;
            padding: 12px 10px;
            text-align: left;
            font-weight: 600;
            color: var(--accent);
            z-index: 10;
            border-bottom: 2px solid var(--border);
            cursor: pointer;
            user-select: none;
        }
        th:hover { background: #2a3540; color: #fff; }
        th::after { content: ' â‡…'; font-size: 10px; opacity: 0.5; margin-left: 5px; }

        td { padding: 8px 10px; border-bottom: 1px solid #2a3540; vertical-align: middle; }
        tr:hover { background: rgba(255,255,255,0.05); }

        /* Cell Visuals */
        .thumb { width: 36px; height: 36px; object-fit: cover; border-radius: 3px; background: #333; }
        .score { font-weight: bold; color: #a1cd44; }
        .price-br { color: #fff; font-weight: 500; }
        .price-us { color: #888; font-size: 11px; }
        .date-rel { font-size: 11px; color: #aaa; display: block; }
        
        /* Badges */
        .plat-icon { 
            display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 4px; 
            background: #333; border: 1px solid #444;
        }
        .plat-icon.active.pc { background: var(--accent); box-shadow: 0 0 6px var(--accent); border-color: transparent;}
        .plat-icon.active.ps { background: var(--ps); box-shadow: 0 0 6px var(--ps); border-color: transparent;}
        .plat-icon.active.xb { background: var(--xbox); box-shadow: 0 0 6px var(--xbox); border-color: transparent;}
        .plat-icon.active.sw { background: var(--switch); box-shadow: 0 0 6px var(--switch); border-color: transparent;}

        .trend-up { color: #a1cd44; }
        .trend-down { color: #cd5444; }
        .status-loading { color: var(--accent); font-style: italic; animation: pulse 1.5s infinite; }
        .status-error { color: #cd5444; }

        .tag-pill { background: #2a475e; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 2px; }
        
        /* Links */
        .db-link, .hltb-link {
            text-decoration: none; padding: 2px 6px; border-radius: 3px; font-size: 11px; transition: 0.2s;
        }
        .db-link { background: #2b1c3d; color: #d8b4fe; border: 1px solid #5a3c7d; }
        .db-link:hover { background: var(--db-color); color: #fff; border-color: #fff; }
        
        .hltb-link { background: #1c2b3d; color: #8fb3e0; border: 1px solid #2a475e; }
        .hltb-link:hover { background: #2D73FF; color: #fff; }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div class="header-row">
        <h1>Steam Pro Analyzer <span style="font-size:12px; opacity:0.6; vertical-align:middle; border:1px solid #a1cd44; color:#a1cd44; padding:2px 5px; border-radius:4px;">Turbo</span></h1>
        <span class="storage-status" id="storageMsg">Cache Local Ativo</span>
    </div>

    <div class="controls">
        <div>
            <textarea id="inputList" placeholder="Cole sua lista de jogos (Links, IDs ou Nomes).&#10;Ex: Baldurs Gate 3, 1086940&#10;Separados por Enter ou vÃ­rgula."></textarea>
        </div>
        <div class="actions">
            <button id="btnProcess" onclick="startBatch()">ðŸš€ PROCESSAR (SEM DELAY)</button>
            <button id="btnExport" onclick="exportToCSV()" style="display:none">ðŸ“¥ BAIXAR CSV</button>
            <div style="display:flex; gap:5px;">
                <button id="btnClear" onclick="clearTable()">Limpar Tabela</button>
                <button id="btnResetStorage" onclick="resetStorage()">Resetar MemÃ³ria</button>
            </div>
        </div>
    </div>

    <div class="filter-container">
        <input type="text" id="tableFilter" class="filter-input" placeholder="ðŸ” Filtrar resultados (ex: 'Unreal', 'RPG', 'Gratis')..." onkeyup="filterTable()">
    </div>

    <div class="progress-container" id="progressBox">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="table-container">
        <table id="dataTable">
            <thead>
                <tr>
                    <th onclick="sortTable(0)">Img</th>
                    <th onclick="sortTable(1)">Nome</th>
                    <th onclick="sortTable(2)">Status</th>
                    <th onclick="sortTable(3)">R$</th>
                    <th onclick="sortTable(4)">USD</th>
                    <th onclick="sortTable(5)">Score</th>
                    <th onclick="sortTable(6)">LanÃ§amento</th>
                    <th onclick="sortTable(7)">Tags</th>
                    <th onclick="sortTable(8)">Engine</th>
                    <th onclick="sortTable(9)">Plataformas</th>
                    <th onclick="sortTable(10)">Players</th>
                    <th onclick="sortTable(11)">TendÃªncia</th>
                    <th onclick="sortTable(12)">HLTB (Est.)</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

<script>
    // --- CONFIGURAÃ‡ÃƒO ---
    // RotaÃ§Ã£o de proxies
    const PROXIES = [
        "https://corsproxy.io/?", 
        "https://api.allorigins.win/raw?url="
    ];
    let currentProxyIndex = 0;

    const ACCEPTED_ENGINES = ['unity', 'unreal', 'gamemaker', 'game maker', 'godot'];
    let processedData = []; 

    // --- CICLO DE VIDA (PERSISTÃŠNCIA) ---
    window.onload = function() {
        loadState();
    };

    function saveState() {
        localStorage.setItem('steam_input', document.getElementById('inputList').value);
        localStorage.setItem('steam_data', JSON.stringify(processedData));
        
        const msg = document.getElementById('storageMsg');
        msg.innerText = "Salvo Ã s " + new Date().toLocaleTimeString();
        setTimeout(() => msg.innerText = "Cache Local Ativo", 2000);
    }

    function loadState() {
        const savedInput = localStorage.getItem('steam_input');
        const savedData = localStorage.getItem('steam_data');

        if(savedInput) document.getElementById('inputList').value = savedInput;
        
        if(savedData) {
            processedData = JSON.parse(savedData);
            if(processedData.length > 0) {
                rebuildTableFromMemory();
                document.getElementById('btnExport').style.display = 'block';
            }
        }
    }

    function resetStorage() {
        if(confirm("Isso apagarÃ¡ todos os dados salvos e a lista. Continuar?")) {
            localStorage.clear();
            location.reload();
        }
    }

    // --- REDE ---
    async function robustFetch(targetUrl) {
        for (let i = 0; i < PROXIES.length; i++) {
            const proxy = PROXIES[(currentProxyIndex + i) % PROXIES.length];
            try {
                const response = await fetch(proxy + encodeURIComponent(targetUrl));
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response; 
            } catch (e) {
                console.warn(`Proxy ${proxy} falhou, tentando prÃ³ximo...`);
            }
        }
        throw new Error("Proxies falharam.");
    }

    // --- PROCESSAMENTO EM LOTE (TURBO - SEM SLEEP) ---
    async function startBatch() {
        const input = document.getElementById('inputList').value;
        if(!input.trim()) return alert("A lista estÃ¡ vazia.");

        localStorage.setItem('steam_input', input);

        processedData = []; 
        document.querySelector('#dataTable tbody').innerHTML = '';
        document.getElementById('btnExport').style.display = 'none';
        
        const progressBox = document.getElementById('progressBox');
        const progressBar = document.getElementById('progressBar');
        progressBox.style.display = 'block';
        progressBar.style.width = '0%';

        let items = input.split(/[\n,;]+/).map(s => s.trim()).filter(s => s.length > 0);
        let total = items.length;

        items.forEach((item, index) => createRowPlaceholder(index, item));

        for (let i = 0; i < total; i++) {
            // [REMOVIDO] Atraso de seguranÃ§a removido para velocidade mÃ¡xima.
            
            try {
                updateCell(i, 2, 'Buscando ID...', 'status-loading'); 
                
                let appId = await resolveID(items[i]);
                updateCell(i, 2, 'Baixando...', 'status-loading');

                let steamData = await fetchSteamBase(appId);
                fillRowBasic(i, steamData);
                
                await Promise.all([
                    verifyExternalData(i, steamData.name, appId),
                    fetchTrends(i, appId),
                    fetchHLTB(i, steamData.name)
                ]);

                updateCell(i, 2, 'OK', 'trend-up');
                
                captureRowData(i, steamData, appId);
                saveState(); 

            } catch (err) {
                console.error(err);
                updateCell(i, 2, 'Erro', 'status-error');
                processedData[i] = { error: true, name: items[i], msg: err.message };
            }

            progressBar.style.width = `${((i+1)/total)*100}%`;
        }
        
        document.getElementById('btnExport').style.display = 'block';
        saveState();
    }

    // --- DOM & TABELA ---
    function createRowPlaceholder(idx, name) {
        const tbody = document.querySelector('#dataTable tbody');
        const tr = document.createElement('tr');
        tr.id = `row-${idx}`;
        let html = `<td><div class="thumb"></div></td>`;
        html += `<td id="cell-${idx}-name">${name}</td>`;
        html += `<td id="cell-${idx}-status" style="font-size:11px">Fila</td>`;
        for(let k=0; k<10; k++) html += `<td id="cell-${idx}-c${k}">---</td>`;
        tr.innerHTML = html;
        tbody.appendChild(tr);
    }

    function updateCell(rowIdx, colIdx, content, cssClass) {
        let targetId;
        if(colIdx === 1) targetId = `cell-${rowIdx}-name`;
        else if(colIdx === 2) targetId = `cell-${rowIdx}-status`;
        else targetId = `cell-${rowIdx}-c${colIdx-3}`;

        const el = document.getElementById(targetId);
        if(el) {
            el.innerHTML = content;
            if(cssClass) el.className = cssClass;
        }
    }

    function fillRowBasic(idx, data) {
        const row = document.getElementById(`row-${idx}`);
        row.querySelector('.thumb').outerHTML = `<img src="${data.img}" class="thumb">`;
        
        const linkName = `<a href="https://store.steampowered.com/app/${data.id}" target="_blank" style="color:#fff;text-decoration:none;font-weight:bold">${data.name}</a><br><span style="font-size:10px;color:#666">ID: ${data.id}</span>`;
        
        updateCell(idx, 1, linkName);
        updateCell(idx, 3, data.priceBr, 'price-br');
        updateCell(idx, 4, data.priceUs, 'price-us');
        updateCell(idx, 5, data.score, 'score');
        
        const relDate = getRelativeTime(data.releaseRaw);
        updateCell(idx, 6, `${data.release}<span class="date-rel">${relDate}</span>`);

        let tagsHtml = data.genres.slice(0,3).map(g => `<span class="tag-pill">${g}</span>`).join('');
        updateCell(idx, 7, tagsHtml || "-");
    }

    // --- RECONSTRUÃ‡ÃƒO ---
    function rebuildTableFromMemory() {
        const tbody = document.querySelector('#dataTable tbody');
        tbody.innerHTML = '';
        
        processedData.forEach((data, idx) => {
            const tr = document.createElement('tr');
            if(data.error) {
                tr.innerHTML = `<td>Err</td><td>${data.name}</td><td class="status-error">${data.msg}</td><td colspan="10"></td>`;
            } else {
                let tags = (data.tags || []).map(t => `<span class="tag-pill">${t}</span>`).join('');
                let plats = '';
                if(data.pc) plats += `<span class="plat-icon pc active"></span>`;
                if(data.ps) plats += `<span class="plat-icon ps active"></span>`;
                if(data.xb) plats += `<span class="plat-icon xb active"></span>`;
                if(data.sw) plats += `<span class="plat-icon sw active"></span>`;

                tr.innerHTML = `
                    <td><img src="${data.img}" class="thumb"></td>
                    <td><a href="${data.link}" target="_blank" style="color:#fff;font-weight:bold">${data.name}</a></td>
                    <td class="trend-up">Restaurado</td>
                    <td class="price-br">${data.priceBr}</td>
                    <td class="price-us">${data.priceUs}</td>
                    <td class="score">${data.score}</td>
                    <td>${data.date}</td>
                    <td>${tags}</td>
                    <td>${data.engineHtml || data.engine}</td>
                    <td>${plats}</td>
                    <td>${data.players}</td>
                    <td class="${data.trend.includes('+')?'trend-up':'trend-down'}">${data.trend}</td>
                    <td>${data.hltbHtml || '-'}</td>
                `;
            }
            tbody.appendChild(tr);
        });
    }

    // --- RESOLVERS & FETCHERS ---

    async function resolveID(input) {
        if (/^\d+$/.test(input)) return input;
        const linkMatch = input.match(/\/app\/(\d+)/);
        if (linkMatch) return linkMatch[1];
        
        const url = `https://store.steampowered.com/search/?term=${input}&category1=998`;
        const res = await robustFetch(url);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");
        const first = doc.querySelector('#search_resultsRows a');
        if(!first) throw new Error("Jogo nÃ£o encontrado");
        return first.getAttribute('data-ds-appid').split(',')[0];
    }

    async function fetchSteamBase(appId) {
        const urlBr = `https://store.steampowered.com/api/appdetails?appids=${appId}&l=brazilian&cc=br`;
        const urlUs = `https://store.steampowered.com/api/appdetails?appids=${appId}&cc=us`;
        
        const [resBr, resUs] = await Promise.all([
            robustFetch(urlBr).then(r=>r.json()), 
            robustFetch(urlUs).then(r=>r.json())
        ]);

        if (!resBr[appId].success) throw new Error("API Restrita/Falha");
        const d = resBr[appId].data;
        const dUs = resUs[appId]?.data;

        return {
            id: appId,
            name: d.name,
            img: d.capsule_image || d.header_image,
            priceBr: d.is_free ? "GrÃ¡tis" : (d.price_overview?.final_formatted || 'N/A'),
            priceUs: d.is_free ? "Free" : (dUs?.price_overview?.final_formatted || 'N/A'),
            score: d.metacritic?.score || '',
            release: d.release_date?.date || 'TBA',
            releaseRaw: d.release_date?.date || '',
            dev: d.developers?.[0] || '',
            genres: d.genres ? d.genres.map(g => g.description) : []
        };
    }

    async function verifyExternalData(idx, gameName, appId) {
        let engineHtml = `<a href="https://steamdb.info/app/${appId}/info/" target="_blank" class="db-link">SteamDB â†—</a>`;
        let enginePlain = "SteamDB";
        let foundPlats = { ps: false, xb: false, sw: false };

        try {
            const sApi = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(gameName + " video game")}&format=json&origin=*`;
            const sRes = await fetch(sApi).then(r=>r.json());
            
            if (sRes.query.search.length > 0) {
                const pApi = `https://en.wikipedia.org/w/api.php?action=parse&page=${encodeURIComponent(sRes.query.search[0].title)}&prop=text&format=json&origin=*`;
                const pRes = await fetch(pApi).then(r=>r.json());
                const doc = new DOMParser().parseFromString(pRes.parse.text['*'], "text/html");
                
                const infobox = doc.querySelector('.infobox');
                let rawEngine = null;
                let allText = "";

                if(infobox) {
                    infobox.querySelectorAll('tr').forEach(r => {
                        const h = r.querySelector('th')?.innerText.toLowerCase()||"";
                        const v = r.querySelector('td')?.innerText||"";
                        if(h.includes('engine')) rawEngine = v;
                        if(h.includes('platform') || h.includes('system')) allText += v + " ";
                    });
                }

                if (rawEngine) {
                    const engLower = rawEngine.toLowerCase();
                    if (ACCEPTED_ENGINES.some(acc => engLower.includes(acc))) {
                        engineHtml = rawEngine.replace(/\[.*?\]/g, ''); 
                        enginePlain = engineHtml;
                    }
                }

                const t = allText.toLowerCase();
                if(t.includes('playstation') || t.includes('ps4') || t.includes('ps5')) foundPlats.ps = true;
                if(t.includes('xbox') || t.includes('series') || t.includes('one')) foundPlats.xb = true;
                if(t.includes('switch') || t.includes('nintendo')) foundPlats.sw = true;
            }
        } catch(e) {}

        const check = async (type, q) => {
            try {
                const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(q)}`;
                const res = await robustFetch(url);
                const html = await res.text();
                if(!html.includes("No results") && html.includes("result__a")) foundPlats[type] = true;
            } catch(e){}
        };

        let promises = [];
        if(!foundPlats.ps) promises.push(check('ps', `site:store.playstation.com "${gameName}"`));
        if(!foundPlats.xb) promises.push(check('xb', `site:xbox.com/pt-br/games/store "${gameName}"`));
        if(!foundPlats.sw) promises.push(check('sw', `site:nintendo.com/pt-br/store "${gameName}"`));
        await Promise.all(promises);

        updateCell(idx, 8, engineHtml);
        
        let platHtml = `<span class="plat-icon pc active" title="PC"></span>`;
        if(foundPlats.ps) platHtml += `<span class="plat-icon ps active" title="PlayStation"></span>`;
        if(foundPlats.xb) platHtml += `<span class="plat-icon xb active" title="Xbox"></span>`;
        if(foundPlats.sw) platHtml += `<span class="plat-icon sw active" title="Switch"></span>`;
        updateCell(idx, 9, platHtml);

        const row = document.getElementById(`row-${idx}`);
        row.dataset.engine = enginePlain;
        row.dataset.ps = foundPlats.ps;
        row.dataset.xb = foundPlats.xb;
        row.dataset.sw = foundPlats.sw;
    }

    async function fetchTrends(idx, appId) {
        try {
            const url = `https://steamcharts.com/app/${appId}`;
            const res = await robustFetch(url);
            const text = await res.text();
            const doc = new DOMParser().parseFromString(text, "text/html");
            
            const current = doc.querySelector('.app-stat .num')?.innerText || "-";
            updateCell(idx, 10, current);

            const rows = doc.querySelectorAll('table.common-table tbody tr');
            let trendTxt = "-";
            let css = "";
            
            if(rows.length > 6) {
                const now = parseFloat(rows[0].children[1].innerText);
                const m6 = parseFloat(rows[6].children[1].innerText);
                const diff = ((now - m6)/m6)*100;
                trendTxt = (diff > 0 ? "+" : "") + diff.toFixed(1) + "%";
                css = diff > 0 ? "trend-up" : "trend-down";
            }
            updateCell(idx, 11, trendTxt, css);
        } catch(e) { updateCell(idx, 11, "?"); }
    }

    async function fetchHLTB(idx, gameName) {
        const url = `https://howlongtobeat.com/?q=${encodeURIComponent(gameName)}`;
        const link = `<a href="${url}" target="_blank" class="hltb-link">Ver HLTB â†—</a>`;
        updateCell(idx, 12, link);
    }

    // --- UTILS ---
    function getRelativeTime(dateString) {
        if(!dateString) return "";
        const date = new Date(dateString);
        if(isNaN(date)) return "";
        const now = new Date();
        const diffTime = now - date;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
        const diffYears = (diffDays / 365).toFixed(1);

        if (diffDays < 0) return " (Em breve)";
        if (diffDays < 30) return " (Recente)";
        if (diffYears >= 1) return ` (HÃ¡ ${diffYears} anos)`;
        return ` (HÃ¡ ${Math.floor(diffDays/30)} meses)`;
    }

    function captureRowData(idx, steamData, appId) {
        const row = document.getElementById(`row-${idx}`);
        
        processedData[idx] = {
            id: appId,
            name: steamData.name,
            link: `https://store.steampowered.com/app/${appId}`,
            img: steamData.img,
            priceBr: steamData.priceBr,
            priceUs: steamData.priceUs,
            score: steamData.score,
            date: steamData.release,
            dev: steamData.dev,
            tags: steamData.genres,
            engine: row.dataset.engine,
            engineHtml: document.getElementById(`cell-${idx}-c5`).innerHTML,
            ps: row.dataset.ps === 'true',
            xb: row.dataset.xb === 'true',
            sw: row.dataset.sw === 'true',
            players: document.getElementById(`cell-${idx}-c7`).innerText,
            trend: document.getElementById(`cell-${idx}-c8`).innerText,
            hltbHtml: document.getElementById(`cell-${idx}-c9`).innerHTML
        };
    }

    function filterTable() {
        const term = document.getElementById('tableFilter').value.toLowerCase();
        const rows = document.querySelectorAll('#dataTable tbody tr');
        rows.forEach(row => {
            const text = row.innerText.toLowerCase();
            row.style.display = text.includes(term) ? '' : 'none';
        });
    }

    function sortTable(n) {
        const table = document.getElementById("dataTable");
        let rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
        switching = true;
        dir = "asc";
        
        while (switching) {
            switching = false;
            rows = table.rows;
            for (i = 1; i < (rows.length - 1); i++) {
                shouldSwitch = false;
                x = rows[i].getElementsByTagName("TD")[n];
                y = rows[i + 1].getElementsByTagName("TD")[n];
                
                let valX = x.innerText.toLowerCase().replace(/[^0-9a-z.-]/g, '');
                let valY = y.innerText.toLowerCase().replace(/[^0-9a-z.-]/g, '');
                
                if(!isNaN(parseFloat(valX)) && !isNaN(parseFloat(valY))) {
                    valX = parseFloat(valX);
                    valY = parseFloat(valY);
                }

                if (dir == "asc") {
                    if (valX > valY) { shouldSwitch = true; break; }
                } else if (dir == "desc") {
                    if (valX < valY) { shouldSwitch = true; break; }
                }
            }
            if (shouldSwitch) {
                rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                switching = true;
                switchcount++;
            } else {
                if (switchcount == 0 && dir == "asc") {
                    dir = "desc";
                    switching = true;
                }
            }
        }
    }

    function clearTable() {
        document.querySelector('#dataTable tbody').innerHTML = '';
        processedData = [];
        localStorage.removeItem('steam_data');
        document.getElementById('btnExport').style.display = 'none';
    }

    function exportToCSV() {
        if(processedData.length === 0) return alert("Nada para exportar");
        let csvContent = "\uFEFFID,Nome,Preco_BRL,Preco_USD,Score,Lancamento,Dev,Engine,Tags,Players,Trend,PC,PSN,Xbox,Switch,Link\n";

        processedData.forEach(row => {
            if(row.error) return;
            const escape = (t) => `"${String(t || '').replace(/"/g, '""')}"`;
            
            let line = [
                row.id, escape(row.name), escape(row.priceBr), escape(row.priceUs), row.score, escape(row.date),
                escape(row.dev), escape(row.engine), escape(row.tags.join(', ')), escape(row.players), escape(row.trend),
                "Sim", row.ps?"Sim":"NÃ£o", row.xb?"Sim":"NÃ£o", row.sw?"Sim":"NÃ£o", row.link
            ].join(",");
            csvContent += line + "\n";
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", "steam_pro_analysis.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
</script>

</body>
</html>
